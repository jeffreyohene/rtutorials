---
title: "Arbeit mit Tabellen"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: yes
    df_print: default
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Was sind Data Frames? Das Indizieren mit $-Operator wird geübt. 
resource_files:
- css/boxes.css
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
```

## Data Frames {data-progressive=TRUE}

### Einführung

Dieses Kapitel zeigt Ihnen die Objektklasse, mit welcher Sie hauptsächlich arbeiten werden. Ein *Data Frame* ist die Art und Weise, wie **Tabellen** in R repräsentiert werden. 

Im letzten Kapitel haben Sie gelernt, dass Vektoren Variablen darstellen und mehrere Werte enthalten können. 

In nächsten Abschnitt lernen Sie, wie Sie mehrere Vektoren in einer Tabelle zusammenbringen können. 

Dass Sie den Umgang mit Tabellen in R lernen, ist essentiell, da die meisten Daten auf dieser Welt irgendwie in Tabellen dargestellt werden.

### Beispiel

Schauen Sie sich die Vektoren `alter` und `tier` im Codeblock an: Sie enthalten jeweils drei Elemente.

Führen Sie den Code aus, um daraus einen Data Frame zu erstellen und anzuzeigen. 

```{r dataframe, exercise = TRUE, exercise.caption = "Data Frame erstellen"}
alter <- c(14, 7, 1)
tier <- c("Hund", "Katze", "Maus")

df <- data.frame(alter, tier)
df
```



### Prinzip

Die Idee eines Data Frames ist, einen Haufen Vektoren gleicher Länge zu nehmen und damit eine Tabelle zu bauen. Dabei ist **jede Spalte ein Vektor**. Anders ausgedrückt: jede Spalte ist eine Variable. 

Das ist eine wichtige Grundstruktur, die Sie sich merken sollten. Im Kern sind Data Frames nichts als Listen von Vektoren gleicher Länge. 

In der Praxis werden Sie zur Dateneingabe ein grafisches Programm wie Excel verwenden, und die fertige Tabelle dann für die Verwendung mit R importieren. Das lernen Sie im Tutorial "Datenimport". 

Wir fokussieren uns hier auf das Hantieren mit Data Frames, denn egal wie Sie die Tabelle
erstellt haben - durch Import aus Excel oder Zusammensetzen einzelner Vektoren, es wird immer ein Data Frame sein in R. 

Wenn im Folgenden immer wieder kleine Data Frames aus Vektoren erstellt werden, dient das nur
dazu, Beispiele zu konstruieren um den Umgang zu erlernen. 

::: infobox
Neue Funktion: `data.frame()`

Erstellt aus einzelnen Vektoren eine Tabelle. Die Vektoren müssen gleich lang sein.
:::

### Neu = Alt

Eine in R übliche Konvention ist die Reihenfolge `NEW = OLD`. 

Das ist beim Assignment so (wo wir gedanklich ein `<-` für das `=` einsetzen):
Links steht immer der neue Name, rechts immer der alte Name oder Inhalt.

Betrachten Sie das folgende Beispiel: 

```{r new_is_old, exercise = TRUE, exercise.caption = "Neu ist Alt"}
# Mitbewohnis in einer WG

# Schema: neu <- alt
x <- c("Hannes", "Mira", "Luisa", "Alex")
y <- c(2000, 2001, 1990, 1995)
alt <- 5.23 

# 2. Data Frame erstellen und dabei Spalten benennen. Gleiches Schema:

wg <- data.frame(
  name = x, 
  jahrgang = y, 
  neu = alt) 
wg
```

Achten Sie auf die Argumente von `data.frame()`: Dort gilt das gleiche Schema. Die "neuen" Namen stehen jeweils auf 
der linken Seite des Gleichheitszeichens, der "alte" Name auf der rechten. 

Das ist gut zu wissen, denn dieses Schema gilt als Konvention für die meisten Bennennungssituationen in R. 

### Eine neue Spalte hinzufügen

Nun wollen wir noch die Zimmergröße der WG-Mitbewohnis mit erfassen. 
Ein einfacher Weg, dem Data Frame eine neue Spalte hinzuzufügen, ist der `$`-Operator.

Sehen Sie sich folgendes Beispiel an:

```{r wg_setupchunk, echo=FALSE}
x <- c("Hannes", "Mira", "Luisa", "Alex")
y <- c(2000, 2001, 1990, 1995)
alt <- 5.23 
wg <- data.frame(
  name = x, 
  jahrgang = y, 
  neu = alt) 
```

```{r dollar, exercise.setup = "wg_setupchunk", exercise = TRUE}
wg$quadratmeter <- c(12, 14, 20, 15)
wg
```

Auch hier gilt wieder das Schema `Alt <- Neu`. 

Im Folgenden erfahren Sie mehr über das Indizieren mit `$`. 

## Listen und der `$`-Operator {data-progressive=TRUE}

Wir werden in diesem Kapitel vom Allgemeinen auf das Spezifische schließen, das heißt, Sie lernen eventuell mehr als Sie müssen, haben aber danach eine bessere Ausgangslage um auch andere spezifische Situationen einzuordnen. 

In diesem Kapitel haben Sie die Chance im Schnelldurchlauf zu verstehen:

- warum ein Data Frame eine Art von Liste ist
- was eine Liste in R ist
- dass Listen `$` zum Indizieren verwenden
- und deshalb auch Data Frames `$` zum Indizieren verwenden. 

### Warum ein Data Frame eine Liste ist

Einen Data Frame können Sie als einen Vektor auffassen, der als Teilemente andere Vektoren enthält. Die grundlegende Datenstruktur in R dafür heißt *Liste*. 

Die Listen-Artige Struktur eines Data Frames wird deutlich, wenn wir uns die Struktur mit `str()` anzeigen lassen:

```{r str, exercise = TRUE, exercise.setup = "dollar"}
str(wg)
```

Wir werden informiert über:

- Die Objektklasse (`data.frame`)
- Die Anzahl an Variablen (4) 
- Anzahl von Beobachtungen (*observations*) je Variable (`4 obs.`)
- Den Datentyp der einzelnen Variablen: 
  
  - `chr` für *character* (Text)
  - `num` für *numeric* (Zahlen)

<br>

Noch deutlicher wird es, wenn wir mit `typeof()` nach dem zugrunde liegenden Datentyp von `wg` fragen. 

```{r typeof, exercise = TRUE, exercise.setup = "dollar"}
typeof(wg)
```


### Was eine Liste in R ist

Eine Liste kann verstanden werden als ein "allgemeiner Vektor", welcher normale Vektoren enthalten kann - und sogar andere Listen (das wird dann aber schnell sehr unübersichtlich). 

Ein ganz zentraler Punkt: Während normale Vektoren *atomic* sind, also immer nur Daten des gleichen Typs beherbergen können, können Listen gemischte Daten enthalten.

Hier ein Beispiel: 

```{r list_example, exercise = TRUE, exercise.setup = "dollar"}
# named vector:
named_vec <- c(
  aepfel = 10,
  birnen = "zwanzig",
  pflaumen = 30)

# Liste:
named_li <- list(
  aepfel = 10,
  birnen = "zwanzig",
  pflaumen = 30)

named_vec
named_li
```

Der Vektor (oben im Output) kann nur Daten eines einzigen Typs enthalten. Da er den Text "zwanzig" enthält, werden die Zahlen automatisch auch zu Text umgeformt und mit Anführungszeichen umgeben. (Siehe auch Tutorial "Vektoren").

Die Liste (unten) hingegen kann problemlos Text und Zahlen gleichzeitig aufnehmen.

Ein weitere Vorteil von Listen ist, dass sie auch Elemente unterschiedlicher Länge enthalten darf. 

Data Frames sind dann eine spezielle Art von Liste - das charakterisierende Merkmal ist, dass alle Elemente die gleiche Länge haben müssen, während das für Listen generell nicht so sein muss. 

### Listen verwenden `$` zum Indizieren

`$` ist speziell für das Indizieren bei benannten Listen gedacht, deswegen haben wir im letzten Abschnitt auch Namen für die Elemente der Liste vergeben. 

Sagen wir mal, wir interessieren uns dafür, was das Listenelement "birnen" so enthält:

```{r list_indexing, exercise = TRUE, exercise.setup = "list_example"}
named_li$birnen
```

<br>

::: aufgabe

Finden Sie heraus, was das Listenelement namens "pflaumen" aus der Liste `named_li` enthält! Verwenden Sie den `$`-Operator. 

:::

```{r dollar_exercise, exercise = TRUE, exercise.setup = "list_example"}

```

```{r dollar_exercise-solution}
named_li$pflaumen
```



`$` ist eine spezielle Art des
Indizierens für Listen, und Data Frames sind in ihrer Grundstruktur einfach Listen.

Data Frames sind in ihrer Grundstruktur Listen. Das ist Hintergrundwissen, dass Sie nur benötigen, um Verbindungslinien zu ziehen zu anderen Situationen, in denen der `$`-Operator auch auf den Plan tritt. Denn `$` ist ein Werkzeug, um Bestandteile einer Liste mit ihrem Namen aufzurufen. 

Wenn Sie andere Objektklassen kennenlernen, die auch fundamental Listen sind, wie zum Beispiel `fit`-Objekte (siehe Tutorial Regression), wird das Erscheinen von `$` Sinn ergeben.

### Data Frames verwenden `$` zum Indizieren

Um das Ganze etwas praktischer zu gestalten, verwenden wir nun mal einen realen Datensatz, der als Data Frame mit im `rtutorials`-Paket enthalten ist.

Erfasst sind dort die tägliche Maximaltemperatur in Grad Fahrenheit, und die Anzahl von durch Überhitzung verursachten Notaufnahme-Fällen in den Krankenhäusern von New York für den jeweiligen Tag. 

Um sich einen Überblick über

### Learnings

- `$` ist ein Werkzeug, um Bestandteile einer Liste mit ihrem Namen aufzurufen. 

## Indizierung bei Data Frames

Um gezielt eine bestimmte Spalte anzusteuern, benötigen Sie den `$`-Operator.

(Beispiel einfügen)

(Exercise einfügen)

An sich können Sie für die Spalten die gleichen Mechanismen verwenden wie für Vektoren, denn es *sind* Vektoren. 

(Beispiel einfügen)

(Exercise)

Bemerken Sie, dass bei Data Frames der Output beim Indizieren mit dem `$`-Operator immer ein Vektor ist.

Es gibt noch eine andere Methode, die bei Data Frames immer auch einen Data Frame zurückgibt.

Das ist ein wichtiger Unterschied! 

### Subsetting mit `[ , ]`

Um nicht nur eine einzelne Spalte herausgreifen zu können, sondern auch mehrere, können wir wieder den Index-Operator nutzen `[]`. Der funktioniert bei Data Frames eigentlich genau wie bei Vektoren, allerdings haben wir nun zwei mögliche Dimensionen: Zeilen und Spalten - anstatt vormals nur einer Dimension bei Vektoren.

Deswegen brauchen wir für Data Frames auch zwei Positionsangaben, mit einem Komma 
getrennt: 

`[Zeilen, Spalten]`

(Beispiel einfügen)

(Exercise)

Bemerken Sie, dass Sie mit `[ , ]` immer einen Data Frame zurückbekommen, während Sie mit `$` nur den jeweiligen Vektor ausgegeben bekommen der die Spalte darstellt.

## Learnings

Data Frames sind Listen von gleichlangen Vektoren.

## Tibbles

(Erklärung)

## Exkurs: Listen



Das charakterisierende Merkmal von Listen ist, dass die einzelnen Inhalte verschiedenen Typs sein dürfen. 

Bei einem Vektor muss der gesamte Vektor den gleichen Datentyp beinhalten.

Viele andere Objekte sind in ihrer Grundstruktur auch Listen, die Sie kennenlernen werden.


(Duplikat von weiter oben, mergen)



## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufgeräumt sind, ist bereits die größte Hürde geschafft. Einen Großteil der Zeit von Datenanalyse verbringen Forschende damit, Daten in die richtige Form zu bringen. Die Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufräumprozess können Sie erleichtern, wenn Sie die Daten von Anfang an so organisieren, dass R gut damit umgehen kann. 

Aber was gibt es eigentlich für Formen in denen Daten sein können?

## 

Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")
library(dplyr)
library(tidyr)
df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```


## 

## Datenerhebung

Wir beginnen damit, Daten zu erheben. Im Wintersemester 2022/23 haben 8 Studierende sich vor Bioläden in und um Kassel gestellt und den Kund_innen Fragen gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und später in Excel oder OpenOffice eingetippt. Damit die Analyse in R später gut funktioniert, müssen die Daten in einer speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum Beispiel:

-   Wie alt sind Sie? -> Variable: Alter

-   Wie weit war Ihr Weg in km? -> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"* formalisiert.

Hier sind drei wichtige Grundregeln für *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

Mit diesen drei Grundregeln werden Sie weniger Kopfschmerzen bei der Analyse von Daten mit R bekommen.

Schauen Sie sich im nächsten Abschnitt an, wie Sie einen mitgelieferten Datensatz aufrufen können!

## Beispieldatensätze

R enthält einige vorinstallierte Datensätze. Außerdem können Beispieldatensätze in Paketen, die Sie laden bereitgestellt werden.

Der von den Studierenden erhobene Datensatz befindet sich in diesem Tutorialpaket und heißt `einkaufen`. Um darauf zuzugreifen, rufen Sie ihn beim Namen:

```{r beispieldaten, exercise = TRUE}
einkaufen

```

::: grau-nb
Der obige Code funktioniert nicht. Das liegt daran, dass der Datensatz aus dem Paket `rtutorials` stammt, dieses Paket im Tutorial-Codeblock aber nicht geladen ist - eine gute Übung für die Praxis, wo es ständig passiert, das Pakete nicht geladen sind. Die Fehlermeldung: "Object not found" ist häufig ein Hinweis darauf, und kann auf zwei Arten gelöst werden:

**Die zwei Schreibweisen, um auf Inhalte aus Paketen zuzugreifen**

-   Um alle Inhalte des Pakets für die aktuelle Sitzung verfügbar zu machen, verwenden Sie `library(Paketname)`. Dann können Sie die Objekte (z.B. Beispieldatensätze) direkt beim Namen aufrufen:\
    \
    `library(rtutorials)`

    `einkaufen`

-   Um nur ein einziges Objekt aus dem Paket aufzurufen, ohne vorher das gesamte Paket zu laden, verwenden Sie `Paketname::Objektname`. Beispiel:\
    `rtutorials::einkaufen`
:::

Warum sind Beispieldatensätze wichtig???

## Literatur
