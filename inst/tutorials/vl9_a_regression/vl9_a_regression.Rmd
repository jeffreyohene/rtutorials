---
title: "Regression"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Einführung in die einfache lineare Regression.
resource_files:
- css/boxes.css
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)

knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

-   Vorannahmen der Regression prüfen

## Lernziele

## Teaser lineare Regression

### Ein Beispiel

Als Förster\*in in den USA stehst du vor einer Amerikanischen Traubenkirsche (*Prunus serotina*) ([wiki](https://de.wikipedia.org/wiki/Sp%C3%A4tbl%C3%BChende_Traubenkirsche)). Sie soll bald gefällt werden, denn sie hat ein begehrtes Holz, und du brauchst Geld. Am liebsten möchtest wissen, bevor du den Baum fällst, wie viele Kubikmeter Holz wohl dabei herauskommen werden, die du verkaufen kannst. Aber du möchtest keine allzu komplexen Messungen vornehmen. Den besten und einfachsten Schätzer, den wir bequem vornehmen können ist der Durchmesser des Baumes, der sich ungefähr aus dem Umfang errechnen lässt. Dafür braucht es lediglich ein Maßband und $\pi$.

Der Baum, vor dem wir stehen, hat einen Durchmesser von 45 cm. Wie viele Kubikmeter Holz können wir erwarten?

```{r out.width= 500}
knitr::include_graphics("images/tree_patrick.jpg")
```

Bild: Kein Kirschbaum, aber zeigt das Prinzip.

*US Army Corps of Engineers. Patrick Bloodgood, photographer. [CC BY 2.0](https://creativecommons.org/licenses/by/2.0), via Wikimedia Commons*

:::{.infobox}
Achtung! **Vereinfachungsalarm**

Wir lassen hier einige Dinge der Einfachheit halber komplett außer Acht, zum Beispiel:

- in der Forstwirtschaft wird zur Schätzung des Volumens eine etwas kompliziertere Formel verwendet, in die neben dem Durchmesser auch die Höhe mit einfließt
- Dabei gibt es verschiedene Volumenmaße für Holz mit und ohne Rinde
- ...
:::

### Beispieldaten

Wir haben bereits Daten von 31 gefällten Bäumen der gleichen Art, und können damit eine Vorhersage treffen. Die Daten befinden sich im `trees`-Datensatz, der in Base R eingebaut ist, und sind der Grund für dieses Beispiel.

Schauen wir uns die Daten mal an:

:::{.aufgabe}
**1.**
Wie sehen die ersten 6 Zeilen des Datensatzes `trees` aus?
:::

```{r head, exercise = TRUE}

```

```{r head-solution}
head(trees)
```

#### Ein bisschen Data-Cleaning

:::{.aufgabe}
**2.**

Die Höhe `Height` lassen wir heute außen vor. 

Der Durchmesser heißt im Datensatz fälschlicherweise `Girth`, was Umfang bedeutet. (Das ist einfach ein Fehler in der Benennung, siehe `?trees`). 

Beheben Sie das, in dem Sie in `trees` eine neue Variable namens `Diameter` erstellen, die den Inhalt der Variable `Girth` enthält.
:::

```{r girth, exercise = TRUE}

```

```{r girth-solution}
trees$Diameter <- trees$Girth
```

:::{.aufgabe}
**3.**

Die Variablen sind (typisch USA) alle in nicht-metrischen Einheiten angegeben. 

Rechnen Sie `Diameter` und `Girth` in metrische Einheiten um, damit das Beispiel intuitiver verständlich ist.

`Diameter` = Inch. Ziel: cm

`Volume` = ft³. Ziel: m³

**Hilfestellung zur Umrechung:**

$cm = Inch * 2.54$

$m^3 = ft^3 * 0.0283168466$

:::
```{r feet-setup}
trees$Diameter <- trees$Girth
```


```{r feet, exercise = TRUE}

```


```{r feet-solution}
trees$Diameter <- trees$Diameter * 2.54 # Inch in cm
trees$Volume <- trees$Volume * 0.0283168466 #  ft³ in m³

```

```{r silentsetup}
trees$Diameter <- trees$Girth * 2.54 # Inch in cm
trees$Volume <- trees$Volume * 0.0283168466 #  ft³ in m³
```


#### Visualisierung

Ein schneller Scatterplot gibt uns jetzt Auskunft über die Beziehung zwischen Durchmesser und Volumen:


```{r, echo = TRUE}
ggplot(trees, aes(x = Diameter, y = Volume)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Durchmesser (cm)", y = "Volumen (m³)")
```

Grundsätzlich sieht es so aus, dass wir mehr Holz ernten, je dicker der Baum war.

Durchmesser und Volumen hängen also irgendwie proportional zusammen. Für unsere Vorhersage wünschen wir uns aber zu wissen, wie genau diese Proportion aussieht.

Glücklicherweise sieht der Zusammenhang linear aus, das heißt, wir könnten ihn sinnvoll mit einer Gerade beschreiben:


```{r echo=F, message=FALSE, warning=FALSE}
ggplot(trees, aes(x = Diameter, y = Volume)) +
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  theme_minimal() +
  labs(x = "Durchmesser (cm)", y = "Volumen (m³)")
```

Die blaue Gerade ist unser Modell, die Punkte sind die Realität, aus der wir das Modell abgeleitet haben. Ein Modell wird den Komplexitäten der Realität nie komplett gerecht, aber manche Modelle sind trotzdem sehr nützlich. Die Gerade hier zum Beispiel ist ein eher einfaches Modell und beschreibt die Realität trotzdem relativ gut. 

Geraden werden beschrieben durch lineare Funktionen. Unser Modell besteht also essentiell aus einer linearen Funktion! Wie genau das alles funktioniert, erfahrt ihr im nächsten Abschnitt. Vorher aber noch ein kleiner Test, ob ihr auch schon mit dem Modell umgehen könnt und die Eingangsfrage lösen könntet:

```{r first}
question_numeric(
  "Wie viel Kubikmeter Holz sind zu erwarten laut der blauen Gerade (unserem linearen Modell) bei einem Durchmesser von 45 cm?",
  answer(1.5, correct = T)
)
```



## lineare Funktionen

Die lineare Funktion kennen sicher alle noch aus der Schule, ca. 8. Klasse:

$$
\hat y = b_0 + b_1\cdot x_1
$$

oder in leicht abgewandelter Form:

$$
y = mx + n
$$

oder:

$$
y = a + bx
$$

Dabei steht $\hat y$ für den durch das Modell vorhergesagten Wert, auch engl. "*response variable"* genannt,"*output variable"* oder Kriterium. Im Beispiel wäre es das Holzvolumen in m³.

$x$ ist der Prädiktor, oder unser *input*, im Beispiel der Baumdurchmesser in Inches.

Daraus ergibt sich für uns folgendes Modell:

$$
\hat{Volumen} = b_0 + b_1 \cdot Durchmesser 
$$

::: infobox
Ein Dach über der Variable kennzeichnet immer, dass es sich hier um einen geschätzten Wert handelt.
:::

Aber was sind $b_0$ und $b_1$?

$b_0$ ist der vorhergesagte Wert, wenn $x$ 0 ist. Das ergibt sich aus der Gleichung:

$\hat y = b_0 + b_1 \cdot 0$

Bei einer Gerade ist $b_0$ also dort, wo $x = 0$. Das ist oft auch dort, wo die y-Achse verläuft, deswegen nennt man $b_0$ auch Achsenabschnitt oder *Intercept* auf Englisch.

$b_1$ ist die Änderung im vorhergesagten Wert ($\hat y$), wenn man $x$ um eine Einheit erhöht. 

Es erinnern sich bestimmt alle an das Dreieck, was man an die Gerade zeichnen kann, um die Steigung zu bestimmen.

Hier einmal eine Beispiel-Gerade, beschrieben durch die Gleichung $\hat y = 9 - 1.5x$.

- Intercept $b_0 = 9$ 
- Steigung $b_1 = -1.5$

```{r}
.gerade <- function(x, intercept = 0, slope = 1){
  intercept + slope * x
}

ggplot() +
  stat_function(fun = `.gerade`, xlim = c(-1, 10), args = list(slope = -1.5, intercept = 9)) +
  geom_segment(aes(x = 2, y = 6, yend = 6, xend = 3), color = "red", 
               arrow = arrow(length = unit(0.03, "npc"))) +
  geom_segment(aes(x = 3, xend = 3, y = 6, yend = 4.5), color = "red",
               arrow = arrow(length = unit(0.03, "npc"))) +
  annotate("text", x = 2.5, y = 6.5, label = "1") +
  annotate("text", x = 3.5, y = 5.125, label = "-1.5") +
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 10), expand = F) +
  scale_y_continuous(breaks = 0:10) +
  scale_x_continuous(breaks = 0:10) +
  theme_minimal()
```

### Quiz

```{r}

ggplot() +
  stat_function(fun = `.gerade`, xlim = c(0, 20),
                args = list(intercept = 5, slope = 0.5)) +
  stat_function(fun = `.gerade`, xlim = c(0, 20),
                args = list(intercept = 10, slope = 1), linetype = "dashed") +
  coord_cartesian(ylim = c(0, 20), xlim = c(0, 20)) +
  theme_minimal()
```

```{r guess}
quiz(
  question_numeric(
  "Welche Steigung (b1) hat die gestrichelte Linie?",
  answer(1, correct = T)
  ),
  question_numeric(
  "Welche Steigung (b1) hat die durchgezogene Linie?",
  answer(0.5, correct = T)
  ),
  question_numeric(
    "Welches Intercept (b0) hat die gestrichelte Linie?",
    answer(10, correct = T)
  ),
  question_numeric(
    "Welches Intercept (b0) hat die durchgezogene Linie?",
    answer(5, correct = T)
  ),
  caption = "Schulmathe auffrischen"
)
```

## Fitting the model

Nun wissen wir also, dass das Modell einer einfachen linearen Regression einfach eine Geradengleichung ist,
beschrieben durch die Parameter $b_0$ (Intercept) und $b_1$ (Steigung.)

Aber wie genau kommen wir auf diese Parameter? Den Prozess, ein Modell zu erstellen, was die Realität möglichst gut erklärt,
nennt man auf Englisch *to fit a model*. 

$b_0$ und $b_1$ werden so gewählt, dass die Gerade einen möglichst kleinen Abstand zu allen Datenpunkten hat. 

```{r residplot, echo=F, message=FALSE, warning=FALSE}
lm(Volume ~ Diameter, data = trees) -> fit
fitted(fit) -> fitted

ggplot(trees, aes(x = Diameter, y = Volume)) +
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  geom_segment(aes(xend = Diameter, yend = fitted, color = "resid")) +
  scale_color_manual(values = c(resid = "darkred"), labels = c(resid = "Residuen")) +
  theme_minimal() +
  labs(x = "Durchmesser (cm)", y = "Volumen (m³)")
```

Die Gerade liegt so, dass die Summe der quadrierten Abstände zu den Datenpunkten minimal ist.

Das könnte man durch sehr langes Ausprobieren und immer wieder optimieren erreichen, aber glücklicherweise gibt es Formeln dafür, die auf direktem Weg die optimale Gerade berechnen können. 

### Umsetzung in R 
In R erhält man die Regressionskoeffizienten $b_0$ und $b_1$ über die Funktion `lm()` (*linear model*).

Fokussieren wir uns zunächst auf die Eingabe, den Output schauen wir uns im nächsten Schritt an.

#### Eingabe
```r
# Modell erstellen und abspeichern 
fit <- lm(Volume ~ Diameter, data = trees)

# Modell ansehen
summary(fit)
```
##### Code Breakdown

`lm()`:

- `Volume ~ Diameter`:
  ist eine Formel, die R sagt: *explain Volume by Diameter*.
  
  Ich finde es hilfreich, die Tilde im Kopf zu lesen als: *explained by* oder auf deutsch "erklärt durch". Links der Tilde kommt immer die Variable hin, die wir erklären oder vorhersagen wollen, und rechts der Tilde die Prädiktoren. 

- `data = trees`:
  Da wir die die Variablennamen verwenden ohne `trees$...` davor, sagen wir R noch im Argument `data`, wo die Variablen zu finden sind.

`fit <-`:

- Schließlich speichern wir das Modell in einem Objekt, was wir `fit` genannt haben, was ein frei ausgewählter Name ist.

`summary(fit)`:

- ruft eine Zusammenfassung unseres gespeicherten Modells auf, was uns zur Ausgabe führt.

#### Ausgabe

Der Output sieht eventuell überwältigend aus, weil er eine ziemlich hohe Informationsdichte hat. Das macht aber gar nichts, denn wir richten unsere Aufmerksamkeit gezielt auf den Abschnitt "Coefficients:". Dort finden wir die Parameter $b_0$ (Intercept)
 und $b_1$ (Steigung). Und zwar in der Spalte "Estimate". 
 
```
Call:
lm(formula = Volume ~ Diameter, data = trees)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.228386 -0.087972  0.004303  0.098961  0.271468 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)    
(Intercept) -1.046122   0.095290  -10.98 7.62e-12 ***
Diameter     0.056476   0.002758   20.48  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.1204 on 29 degrees of freedom
Multiple R-squared:  0.9353,	Adjusted R-squared:  0.9331 
F-statistic: 419.4 on 1 and 29 DF,  p-value: < 2.2e-16
```
Daraus können wir entnehmen: 

- Intercept $b_0 = -1.0461$
- Steigung $b_1 = 0.0565$ 

Alle anderen Spalten interessieren uns im Moment nicht. 

```
Coefficients:
             Estimate    
(Intercept) -1.046122   <--- b0
Diameter     0.056476   <--- b1
---
```

Jetzt sind Sie dran!

:::{.aufgabe}
**1.**

Erstellen Sie mit `lm()` ein lineares Modell zur Erklärung des Volumens durch den Durchmesser im `trees`-Datensatz und speichern Sie es ab als `fit`.
:::

```{r model, exercise = TRUE}

```

```{r model-solution}
fit <- lm(Volume ~ Diameter, data = trees)
```


:::{.aufgabe}
**2.**

Lassen Sie sich mit `summary()` eine Zusammenfassung des gespeicherten Modells ausgeben!

Finden Sie $b_0$ und $b_1$!
:::
```{r summary-setup}
trees$Diameter <- trees$Girth * 2.54 # Inch in cm
trees$Volume <- trees$Volume * 0.0283168466 #  ft³ in m³
fit <- lm(Volume ~ Diameter, data = trees)
```

```{r summary, exercise = TRUE}

```

```{r summary-solution}
summary(fit)
```


## Interpretation der Koeffizienten

Jetzt haben wir $b_0 = -1.0461$ und $b_1 = 0.0565$ herausgefunden - aber was heißen sie eigentlich inhaltlich?

Zunächst einmal können wir uns merken, dass die Regressionskoeffizienten in Einheiten der vorhergesagten Variable, in unserem Fall also
Volumen (m³) sind. 

### Interpretation $b_0$ (Intercept)

> „$b_0$ ist der vorhergesagte Wert, wenn der Prädiktor den Wert 0 annimt. Bezogen auf das Beispiel:
>
> Wenn der Durchmesser eines Baumes 0 cm betragen würde, wäre das vorhergesagte Holzvolumen -1.05 Kubikmeter.“

Das ist in diesem Fall (und in vielen anderen auch) keine sinnvolle Interpretation - es gibt keinen Baum, wenn er einen Durchmesser von 0 cm hat, und es gibt auch kein negatives Volumen. Mehr dazu im Abschnitt Transformationen.

### Interpretation $b_1$ (Steigung)

>„$b_1$ ist die vorhergesagte Änderung, wenn der Prädiktor um eine Einheit erhöht wird. 
>
>Pro Zentimeter Durchmesser mehr steigt also unser erwartetes Volumen um 0.0565 Kubikmeter.“

## Transformationen

## Vorraussetzungen prüfen

## Abschlussquiz

## Learnings
